initial communicator := { 1 -> 1/4, 2 -> 1/4, 3 -> 1/4, 4 -> 1/4 };
new nodes := 4;

new last_my_bit := { 0 -> 1/2, 1 -> 1/2 };
new last_their_bit := 0;

# is_communicator: 1 if this node is the communicator, 0 if not
# their_bit: the private bit generated by the other node
function announce(index, is_communicator, their_bit) {
	new my_bit := 0;
	if (index == nodes - 1) {
		my_bit := last_my_bit
	} else {
		my_bit := { 0 -> 1/2, 1 -> 1/2 }
	};
	
	new announcement := my_bit xor their_bit;
	# If we're the communicator, invert our announcement
	if (is_communicator == 1) { announcement := announcement xor 1 };
	
	# Store the bit we just generated, so the next node can use it
	last_their_bit := my_bit;
	
	output announcement
};

function main() {
	new i := 0;
	while (i < nodes) {
		new is_communicator := 0;
		if (i + 1 == communicator) { is_communicator := 1 };
		
		# announce() updates the value of last_their_bit:
		if (i == 0) {
			announce(i, is_communicator, last_my_bit)
		} else {
			announce(i, is_communicator, last_their_bit)
		};
		
		i := i + 1
	}
};

main()
