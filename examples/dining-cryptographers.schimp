initial billpayer := { 1 -> 1/4, 2 -> 1/4, 3 -> 1/4, 4 -> 1/4 };
new cryptographers := 4;

new last_my_bit := { 0 -> 1/2, 1 -> 1/2 };
new last_their_bit := 0;

# is_billpayer: 1 if this cryptographer is the bill-payer, 0 if not
# their_bit: the private bit generated by the other cryptographer
function announce(index, is_billpayer, their_bit) {
	new my_bit := 0;
	if (index == cryptographers - 1) {
		my_bit := last_my_bit
	} else {
		my_bit := { 0 -> 1/2, 1 -> 1/2 }
	};
	
	new announcement := my_bit xor their_bit;
	# If we're the bill-payer, invert our announcement
	if (is_billpayer == 1) { announcement := announcement xor 1 };
	
	# Store the bit we just generated, so the next cryptographer can use it
	last_their_bit := my_bit;
	
	output announcement
};

function main() {
	new i := 0;
	while (i < cryptographers) {
		new is_billpayer := 0;
		if (i + 1 == billpayer) { is_billpayer := 1 };
		
		# announce() updates the value of last_their_bit:
		if (i == 0) {
			announce(i, is_billpayer, last_my_bit)
		} else {
			announce(i, is_billpayer, last_their_bit)
		};
		
		i := i + 1
	}
};

main()
