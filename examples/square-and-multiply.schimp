# Secret key used for encryption:
initial e := {
	1 -> 1/64, 2 -> 1/64, 3 -> 1/64, 4 -> 1/64, 5 -> 1/64, 6 -> 1/64, 7 -> 1/64, 8 -> 1/64,
	9 -> 1/64, 10 -> 1/64, 11 -> 1/64, 12 -> 1/64, 13 -> 1/64, 14 -> 1/64, 15 -> 1/64, 16 -> 1/64,
	17 -> 1/64, 18 -> 1/64, 19 -> 1/64, 20 -> 1/64, 21 -> 1/64, 22 -> 1/64, 23 -> 1/64, 24 -> 1/64,
	25 -> 1/64, 26 -> 1/64, 27 -> 1/64, 28 -> 1/64, 29 -> 1/64, 30 -> 1/64, 31 -> 1/64, 32 -> 1/64,
	33 -> 1/64, 34 -> 1/64, 35 -> 1/64, 36 -> 1/64, 37 -> 1/64, 38 -> 1/64, 39 -> 1/64, 40 -> 1/64,
	41 -> 1/64, 42 -> 1/64, 43 -> 1/64, 44 -> 1/64, 45 -> 1/64, 46 -> 1/64, 47 -> 1/64, 48 -> 1/64,
	49 -> 1/64, 50 -> 1/64, 51 -> 1/64, 52 -> 1/64, 53 -> 1/64, 54 -> 1/64, 55 -> 1/64, 56 -> 1/64,
	57 -> 1/64, 58 -> 1/64, 59 -> 1/64, 60 -> 1/64, 61 -> 1/64, 62 -> 1/64, 63 -> 1/64, 64 -> 1/64
};
new e_bits := 7; # = log2 e + 1

# Message to encrypt (actual value not important):
new a := 42;

# Publicly-known constant:
new n := 13;

# Used to return results from square_mod() and multiply_mod():
new res := 0;

# Computes a^e mod n
function square_and_multiply(a, e, n) {
	new b := 1;
	
	new i := e_bits;
	while (i > 0) {
		square_mod(b, n); # -> res
		b := res;
		bit_at(e, i); # -> res
		if (res == 1) {
			multiply_mod(b, a, n); # -> res
			b := res
		};
		
		i := i - 1
	};
	
	output b
};

function square_mod(x, m) {
	res := x * x mod n
};

function multiply_mod(x, y, m) {
	res := x * y mod n
};

# Returns the n'th bit of x (either 0 or 1) - lowest bit is n=1
function bit_at(x, n) {
	res := floor (x / 2 ^ (n - 1)) mod 2
};

square_and_multiply(a, e, n)
